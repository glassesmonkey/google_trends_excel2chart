# Google Trends 数据可视化工具

## 产品设计思路

### 1. 核心功能定位
- 批量处理和分析 Google Trends 数据
- 数据可视化展示
- 研究进度管理
- 多设备数据同步

### 2. 数据流设计
#### 2.1 数据存储架构
- 云端存储：
  - 未研究数据：`trends_data.json`
  - 已研究数据：`reviewed_trends_data.json`
  - 分离存储确保数据管理的清晰度

#### 2.2 数据同步策略
- 批量处理：每批100条数据
- 自动重试机制：
  - 最大重试次数：3次
  - 指数退避延迟
  - 批次间500ms间隔
- 数据合并策略：
  - 使用 targetKeyword 作为唯一标识
  - 保留最新时间戳的数据
  - 已研究状态优先保留

### 3. 用户界面设计
#### 3.1 数据展示
- 卡片式布局
- 每页12条数据
- 无限滚动加载
- 响应式设计：
  - 移动端：单列
  - 平板：双列
  - 桌面：三列
  - 大屏：四列

#### 3.2 数据筛选与排序
- 搜索功能：关键词实时过滤
- 多维度排序：
  - 月均搜索量
  - 热度评分
  - 近7日数据
  - 时间顺序
- 数据状态过滤：
  - 未研究数据
  - 所有数据

#### 3.3 批量操作
- 全选功能
- 批量标记已研究
- 清除已研究数据

### 4. 数据分析功能
#### 4.1 趋势分析
- 双曲线对比：
  - GPTs趋势
  - 目标关键词趋势
- 关键指标计算：
  - 月均搜索量
  - 热度评分算法
  - 近7日搜索量

#### 4.2 热度评分算法
- 基于时间衰减模型：
  - 7天内：100分
  - 14天内：90分
  - 30天内：80分
  - 60天内：60分
  - 90天内：40分
  - 180天内：20分
  - 其他：10分
- 考虑因素：
  - 流量基准（平均流量的10%为阈值）
  - 相对增长（2倍增长判定）
  - 时间衰减

### 5. 技术实现
#### 5.1 前端技术栈
- Next.js 15.1.2
- React
- TypeScript
- TailwindCSS
- ECharts
- Zustand

#### 5.2 数据存储
- Google Drive API
  - 文件级权限
  - 应用专属文件夹
- 本地存储
  - LocalStorage 缓存
  - Token 管理

#### 5.3 性能优化
- 批量数据处理
- 请求重试机制
- 延迟加载
- 数据缓存

### 6. 项目结构
```
google-trends-visualizer/
├── app/                 # Next.js 应用目录
├── components/         # React 组件
│   ├── DataTable      # 数据表格组件
│   ├── FileUploader   # 文件上传组件
│   └── TrendsChart    # 趋势图表组件
├── lib/               # 核心库
│   └── googleDrive    # Google Drive 服务
├── store/             # 状态管理
├── types/             # TypeScript 类型定义
└── utils/             # 工具函数
```

## 开发环境设置

### 1. 环境要求
- Node.js >= 14.0.0
- npm >= 6.0.0

### 2. 安装依赖
```bash
npm install
```

### 3. 环境变量配置
```env
NEXT_PUBLIC_GOOGLE_CLIENT_ID=your_client_id
NEXT_PUBLIC_REDIRECT_URI=your_redirect_uri
```

### 4. 开发服务器
```bash
npm run dev
```

## 部署说明

### 1. 构建项目
```bash
npm run build
```

### 2. 启动生产服务器
```bash
npm start
```

## 注意事项

### 1. 数据处理
- 单次上传建议不超过1000个文件
- 大量数据处理时会自动分批
- 确保网络稳定性

### 2. Google Drive API
- 需要配置适当的API权限
- 注意API限流问题
- Token 过期处理

### 3. 性能考虑
- 大量数据处理时注意内存使用
- 避免频繁API调用
- 合理使用缓存机制

